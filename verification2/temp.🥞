fun pnk_modulo(1 a, 1 b) {
    var result = a & (b - 1);
    return result;
}
fun net_queue_empty(1 queue_ptr) {
    var tail = 0; !ldw tail, queue_ptr;
    var head = 0; !ldw head, queue_ptr + @biw;
    var empty = (tail - head) == 0;
    return empty;
}
fun net_queue_full(1 queue, 1 length) {
    var tail = 0; !ldw tail, queue;
    var head = 0; !ldw head, queue + @biw;
    var full = (tail - head) == length;
    return full;
}
fun net_enqueue(1 queue, 1 capacity, 1 buffer_addr) {
    var 1 full = net_queue_full(queue, capacity);
    if (full) {
        return -1;
    }
    var tail = 0; !ldw tail, queue;
    var 1 idx = pnk_modulo(tail, capacity);
    var buff = (queue + 3 * @biw + idx * (2 * @biw));
    var buffer = lds {1,1} buffer_addr;
    !stw buff, (buffer.0);
    !stw buff + @biw, (buffer.1);
    tail = tail + 1;
    !stw queue, tail;
    return 0;
}
fun net_dequeue(1 queue, 1 capacity) {
    var 1 empty = net_queue_empty(queue);
    if (empty) {
        return <-1, -1>;
    }
    var head = 0; !ldw head, queue + @biw;
    var 1 idx = pnk_modulo(head, capacity);
    var buff = (queue + 3 * @biw + idx * (2 * @biw));
    var io_or_offset = 0;
    !ldw io_or_offset, buff;
    var len = 0;
    !ldw len, buff + @biw;
    head = head + 1;
    !stw queue + @biw, head;
    return <io_or_offset, len>;
}
fun net_request_signal(1 queue_ptr)
{
    var signal = 0;
    !st8 queue_ptr + 2 * @biw, signal;
    return 0;
}
fun net_cancel_signal(1 queue_ptr)
{
    var signal = 1;
    !st8 queue_ptr + 2 * @biw, signal;
    return 0;
}
fun net_require_signal(1 queue_ptr)
{
    var signalled = 0;
    !ld8 signalled, queue_ptr + 2 * @biw;
    return !signalled;
}
fun get_device_EIR()
{
    var eth = (lds 1 @base);
    var eir = 0;
    !ld32 eir, (eth + 4);
    var result = <0,0>;
    if (eir & (1 << 25)) {
        if (eir & (1 << 27)) {
            result = <1,1>;
        } else {
            result = <1,0>;
        }
    } else {
        if (eir & (1 << 27)) {
            result = <0,1>;
        } else {
            result = <0,0>;
        }
    }
    return result;
}
fun clear_device_EIR()
{
    var eth = (lds 1 @base);
    !st32 (eth + 4), ((1 << 25) | (1 << 27) | (1 << 22));
    return 0;
}
fun set_device_RDAR()
{
    var eth = (lds 1 @base);
    !st32 (eth + 16), (1 << 24);
    return 0;
}
fun set_device_TDAR()
{
    var eth = (lds 1 @base);
    !st32 (eth + 20), (1 << 24);
    return 0;
}
fun descriptor_get_len(1 descriptor)
{
    var result = descriptor & 65535;
    return result;
}
fun rx_descriptor_empty(1 descriptor)
{
    var stat = (descriptor >> 16) & 65535;
    var empty = (stat & (1 << 15)) != 0;
    return empty;
}
fun tx_descriptor_ready(1 descriptor)
{
    var stat = (descriptor >> 16) & 65535;
    var ready = (stat & (1 << 15)) != 0;
    return ready;
}
fun rx_update_device_ring_slot(1 descr, 1 idx, {1, 1} net_buffer, 1 hw_capacity)
{
    var dst_addr = (descr + idx * 8);
    var stat = (1 << 15);
    if (idx + 1 == hw_capacity) {
        stat = stat | (1 << 13);
    }
    var io_or_offset = net_buffer.0;
    var len = net_buffer.1;
    var descriptor = (stat << 16) | len;
    !st32 dst_addr + 4, io_or_offset;
    !st32 dst_addr, descriptor;
    return 0;
}
fun tx_update_device_ring_slot(1 descr, 1 idx, {1, 1} net_buffer, 1 hw_capacity)
{
    var dst_addr = (descr + idx * 8);
    var stat = ((1 << 15) | (1 << 10) | (1 << 11));
    if (idx + 1 == hw_capacity) {
        stat = stat | (1 << 13);
    }
    var io_or_offset = net_buffer.0;
    var len = net_buffer.1;
    var descriptor = (stat << 16) | len;
    !st32 dst_addr + 4, io_or_offset;
    !st32 dst_addr, descriptor;
    return 0;
}
