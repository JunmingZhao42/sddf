/*
* Copyright 2022, UNSW
* SPDX-License-Identifier: BSD-2-Clause
*/
/* The reference manual used to acquire these values is:
*
* i.MX 8M Mini Applications Processor Reference Manual.
* Document number: IMX8MMRM.
* Rev. 3, 11/2020.
*
* The ethernet device is described in section 11.5.
*/

#define NETIRQ_TXF      (1 << 27) /* Transmit Frame Interrupt        */
#define NETIRQ_RXF      (1 << 25) /* Receive Frame Interrupt         */
#define NETIRQ_EBERR    (1 << 22) /* Ethernet bus error              */
#define IRQ_MASK        (NETIRQ_RXF | NETIRQ_TXF | NETIRQ_EBERR)

#define RXD_EMPTY       (1 << 15)
#define WRAP            (1 << 13)

#define TXD_READY       (1 << 15)
#define TXD_ADDCRC      (1 << 10)
#define TXD_LAST        (1 << 11)
#define TXD_STAT        (TXD_READY | TXD_ADDCRC | TXD_LAST)

#define RDAR_RDAR       (1 << 24) /* RX descriptor active */
#define TDAR_TDAR       (1 << 24) /* TX descriptor active */

#define ETH_REGS        (lds 1 @base)

#define EIR_OFFSET                      4
#define EIMR_OFFSET                     8
#define RDAR_OFFSET                     16
#define TDAR_OFFSET                     20

// Todo: associate these with device state

// EIR: Interrupt Event Register
// Manual section 11.5.5.1

// We set EMIR to IRQ_MASK at the start, meaning we only get
// IRQs for RXF and TXF.
fun get_device_EIR()
{
    var eth = ETH_REGS;
    var eir = 0;
    !ld32 eir, (eth + EIR_OFFSET);
    return eir;
}

fun is_EIR_RXF(1 eir)
{
    return (eir & NETIRQ_RXF) != 0;
}

fun is_EIR_TXF(1 eir)
{
    return (eir & NETIRQ_TXF) != 0;
}

// Writing a 1 to an EIR bit clears it; writing 0 has no effect.
fun clear_device_EIR()
{
    var eth = ETH_REGS;
    !st32 (eth + EIR_OFFSET), IRQ_MASK;
    return 0;
}

fun set_device_RDAR()
{
    var eth = ETH_REGS;
    !st32 (eth + RDAR_OFFSET), RDAR_RDAR;
    return 0;
}

fun set_device_TDAR()
{
    var eth = ETH_REGS;
    !st32 (eth + TDAR_OFFSET), TDAR_TDAR;
    return 0;
}

fun descriptor_get_len(1 descriptor)
{
    var result = descriptor & MASK_16;
    return result;
}

fun rx_descriptor_empty(1 descriptor)
{
    var stat = (descriptor >> 16) & MASK_16;
    var empty = (stat & RXD_EMPTY) != 0;
    return empty;
}

fun tx_descriptor_ready(1 descriptor)
{
    var stat = (descriptor >> 16) & MASK_16;
    var ready = (stat & TXD_READY) != 0;
    return ready;
}

#define HW_CAPACITY         256
#define DESCRIPTROR_SIZE    8
#define DESCRP_ADDR_IDX(descr, idx)    (descr + idx * DESCRIPTROR_SIZE)

// Todo: change this hack once !st16/!ld16 is supported in pancake
fun rx_update_device_ring_slot(1 descr, 1 idx, {1, 1} net_buffer, 1 hw_capacity)
{
    var dst_addr = DESCRP_ADDR_IDX(descr, idx);
    var stat = RXD_EMPTY;
    if (idx + 1 == hw_capacity) {
        stat = stat | WRAP;
    }
    var io_or_offset = net_buffer.0;
    var len = net_buffer.1;
    var descriptor = (stat << 16) | len;
    !st32 dst_addr + 4, io_or_offset;
    !st32 dst_addr, descriptor;
    return 0;
}

fun tx_update_device_ring_slot(1 descr, 1 idx, {1, 1} net_buffer, 1 hw_capacity)
{
    var dst_addr = DESCRP_ADDR_IDX(descr, idx);
    var stat = TXD_STAT;
    if (idx + 1 == hw_capacity) {
        stat = stat | WRAP;
    }
    var io_or_offset = net_buffer.0;
    var len = net_buffer.1;
    var descriptor = (stat << 16) | len;
    !st32 dst_addr + 4, io_or_offset;
    !st32 dst_addr, descriptor;
    return 0;
}