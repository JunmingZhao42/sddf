/**
 * Get the number of buffers enqueued into a queue.
 *
 * @param queue queue handle for the queue to get the size of.
 *
 * @return number of buffers enqueued into a queue.
 */
#define net_queue_size(size, queue) \
    get_tail(tail, queue)           \
    get_head(head, queue)           \
    var size = (tail - head);       \

/**
 * Check if the free queue is empty.
 *
 * @param queue queue handle for the free queue to check.
 *
 * @return true indicates the queue is empty, false otherwise.
 */
#define net_queue_empty_free(empty, queue_handle)   \
    get_free_tail(tail, queue_handle)               \
    get_free_head(head, queue_handle)               \
    var empty = (tail - head) == 0;                 \

/**
 * Check if the active queue is empty.
 *
 * @param queue queue handle for the active queue to check.
 *
 * @return true indicates the queue is empty, false otherwise.
 */
#define net_queue_empty_active(empty, queue_handle)     \
    get_active_tail(tail, queue_handle)                 \
    get_active_head(head, queue_handle)                 \
    var empty = (tail - head) == 0;                     \

/**
 * Check if the free queue is full.
 *
 * @param queue queue handle t for the free queue to check.
 *
 * @return true indicates the queue is full, false otherwise.
 */
#define net_queue_full_free(full, queue_handle)     \
    get_free_tail(tail, queue_handle)               \
    get_free_head(head, queue_handle)               \
    get_size(size, queue_handle)                    \
    var full = (tail + 1 - head) == size;           \

/**
 * Check if the active queue is full.
 *
 * @param queue queue handle for the active queue to check.
 *
 * @return true indicates the queue is full, false otherwise.
 */
#define net_queue_full_active(full, queue_handle)   \
    get_active_tail(tail, queue_handle)             \
    get_active_head(head, queue_handle)             \
    get_size(size, queue_handle)                    \
    var full = (tail + 1 - head) == size;           \

/**
 * Enqueue an element into a free queue.
 *
 * @param queue queue to enqueue into.
 * @param buffer buffer descriptor for buffer to be enqueued.
 *
 * @return -1 when queue is full, 0 on success.
 */
fun net_enqueue_free(1 queue_handle, 2 buffer) {
    net_queue_full_free(full, queue_handle)
    if (full) {
        return -1;
    }

    get_size(size, queue_handle)
    get_free_tail(tail, queue_handle)
    pnk_modulo(idx, tail, size)

    get_free_queue(free, queue_handle)
    get_buffer_desc_addr(buff, idx, free)

    !stw buff, (buffer.0);
    !stw buff + WORD_SIZE, (buffer.1);

// TODO: #ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE()

    tail = tail + 1;
    set_free_tail(tail, queue_handle)
    return 0;
}

/**
 * Enqueue an element into an active queue.
 *
 * @param queue queue to enqueue into.
 * @param buffer buffer descriptor for buffer to be enqueued.
 *
 * @return -1 when queue is full, 0 on success.
 */
fun net_enqueue_active(1 queue_handle, 2 buffer) {
    net_queue_full_active(full, queue_handle)
    if (full) {
        return -1;
    }

    get_size(size, queue_handle)
    get_active_tail(tail, queue_handle)
    pnk_modulo(idx, tail, size)

    get_active_queue(active, queue_handle)
    get_buffer_desc_addr(buff, idx, active)

    !stw buff, (buffer.0);
    !stw buff + WORD_SIZE, (buffer.1);

    THREAD_MEMORY_RELEASE()

    tail = tail + 1;
    set_active_tail(tail, queue_handle)
    return 0;
}

/**
 * Dequeue an element from the free queue.
 *
 * @param queue queue handle to dequeue from.
 * @param buffer pointer to buffer descriptor for buffer to be dequeued.
 *
 * @return -1 when queue is empty, 0 on success.
 */
fun net_dequeue_free(1 queue_handle, 1 buffer_addr) {
    net_queue_empty_free(empty, queue_handle)
    if (empty) {
        return -1;
    }

    get_size(size, queue_handle)
    get_free_head(head, queue_handle)
    pnk_modulo(idx, head, size)

    get_free_queue(free, queue_handle)
    get_buffer_desc_addr(buff, idx, free)

    var buf_v = 0;
    !ldw buf_v, buff;
    !stw buffer_addr, buf_v;
    !ldw buf_v, buff + WORD_SIZE;
    !stw buffer_addr + WORD_SIZE, buf_v;
    THREAD_MEMORY_RELEASE()

    head = head + 1;
    set_free_head(head, queue_handle)
    return 0;
}

/**
 * Dequeue an element from the active queue.
 *
 * @param queue queue handle to dequeue from.
 * @param buffer pointer to buffer descriptor for buffer to be dequeued.
 *
 * @return -1 when queue is empty, 0 on success.
 */
fun net_dequeue_active(1 queue_handle, 1 buffer_addr) {
    net_queue_empty_active(empty, queue_handle)
    if (empty) {
        return -1;
    }

    get_size(size, queue_handle)
    get_active_head(head, queue_handle)
    pnk_modulo(idx, head, size)
    get_active_queue(active, queue_handle)
    get_buffer_desc_addr(buff, idx, active)

    var buf_v = 0;
    !ldw buf_v, buff;
    !stw buffer_addr, buf_v;
    !ldw buf_v, buff + WORD_SIZE;
    !stw buffer_addr + WORD_SIZE, buf_v;

    THREAD_MEMORY_RELEASE()

    head = head + 1;
    set_active_head(head, queue_handle)
    return 0;
}

/**
 * Initialise the shared queue.
 *
 * @param queue queue handle to use.
 * @param free pointer to free queue in shared memory.
 * @param active pointer to active queue in shared memory.
 * @param size size of the free and active queues.
 */
#define net_queue_init(queue_handle, free, active, size)    \
    set_free_queue(free, queue_handle)                      \
    set_active_queue(active, queue_handle)                  \
    set_queue_size(size, queue_handle)                      \


/**
 * Initialise the free queue by filling with all free buffers.
 *
 * @param queue queue handle to use.
 * @param base_addr start of the memory region the offsets are applied to (only used between virt and driver)
 */
fun net_buffers_init(1 queue_handle, 1 base_addr) {
    // TODO
    return 0;
}

/**
 * Indicate to producer of the free queue that consumer requires signalling.
 *
 * @param queue queue handle of free queue that requires signalling upon enqueuing.
 */
#define net_request_signal_free(queue_handle)   \
    get_free_queue(queue, queue_handle)         \
    clear_consumer_signalled(queue)             \
    THREAD_MEMORY_RELEASE()                     \

/**
 * Indicate to producer of the active queue that consumer requires signalling.
 *
 * @param queue queue handle of active queue that requires signalling upon enqueuing.
 */
#define net_request_signal_active(queue_handle)     \
    get_active_queue(queue, queue_handle)           \
    clear_consumer_signalled(queue)                 \
    THREAD_MEMORY_RELEASE()                         \

/**
 * Indicate to producer of the free queue that consumer has been signalled.
 *
 * @param queue queue handle of the free queue that has been signalled.
 */
#define net_cancel_signal_free(queue_handle)    \
    get_free_queue(queue, queue_handle)         \
    set_consumer_signalled(queue)               \
    THREAD_MEMORY_RELEASE()                     \

/**
 * Indicate to producer of the active queue that consumer has been signalled.
 *
 * @param queue queue handle of the active queue that has been signalled.
 */
#define net_cancel_signal_active(queue_handle)      \
    get_active_queue(queue, queue_handle)           \
    set_consumer_signalled(queue)                   \
    THREAD_MEMORY_RELEASE()                         \

/**
 * Consumer of the free queue requires signalling.
 *
 * @param queue queue handle of the free queue to check.
 */
#define net_require_signal_free(signal, queue_handle)       \
    get_free_queue(queue, queue_handle)                     \
    get_consumer_signalled(signalled, queue)                \
    var signal = (!signalled);

/**
 * Consumer of the active queue requires signalling.
 *
 * @param queue queue handle of the active queue to check.
 */
#define net_require_signal_active(signal, queue_handle)     \
    get_active_queue(queue, queue_handle)                   \
    get_consumer_signalled(signalled, queue)                \
    var signal = (!signalled);

