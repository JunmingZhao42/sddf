/**
 * Get the number of buffers enqueued into a queue.
 *
 * @param queue queue handle for the queue to get the size of.
 *
 * @return number of buffers enqueued into a queue.
 */
#define net_queue_size(size, queue) \
    get_tail(tail, queue)           \
    get_head(head, queue)           \
    var size = (tail - head);       \

/**
 * Check if the network queue queue is empty.
 *
 * @param queue queue to check.
 *
 * @return true indicates the queue is empty, false otherwise.
 */
#define net_queue_empty(empty, queue)   \
    get_tail(tail, queue)               \
    get_head(head, queue)               \
    var empty = (tail - head) == 0;     \

/**
 * Check if the network queue is full.
 *
 * @param queue queue to check.
 *
 * @return true indicates the queue is full, false otherwise.
 */
#define net_queue_full(full, queue, size)   \
    get_tail(tail, queue)                   \
    get_head(head, queue)                   \
    var full = (tail - head) == size;   \

/**
 * Enqueue an element into a queue.
 *
 * @param queue queue to enqueue into.
 * @param size size of the queue.
 * @param buffer buffer descriptor for buffer to be enqueued.
 *
 * @return -1 when queue is full, 0 on success.
 */
fun net_enqueue(1 queue, 1 size, 2 buffer) {
    net_queue_full(full, queue, size)
    if (full) {
        return -1;
    }

    get_tail(tail, queue)
    pnk_modulo(idx, tail, size)
    get_buffer_desc_addr(buff, idx, queue)

    !stw buff, (buffer.0);
    !stw buff + @biw, (buffer.1);

// TODO: #ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE()

    tail = tail + 1;
    set_tail(tail, queue)
    return 0;
}

/**
 * Dequeue an element from the network queue.
 *
 * @param queue queue handle to dequeue from.
 * @param size size of the queue.
 * @param buffer pointer to buffer descriptor for buffer to be dequeued.
 *
 * @return -1 when queue is empty, 0 on success.
 */
fun net_dequeue(1 queue, 1 size, 1 buffer_addr) {
    net_queue_empty(empty, queue)
    if (empty) {
        return -1;
    }

    get_head(head, queue)
    pnk_modulo(idx, head, size)
    get_buffer_desc_addr(buff, idx, queue)

    var buf_v = 0;
    !ldw buf_v, buff;
    !stw buffer_addr, buf_v;
    !ldw buf_v, buff + @biw;
    !stw buffer_addr + @biw, buf_v;
    THREAD_MEMORY_RELEASE()

    head = head + 1;
    set_head(head, queue)
    return 0;
}

/**
 * Indicate to producer of the queue that consumer requires signalling.
 *
 * @param queue queue that requires signalling upon enqueuing.
 */
#define net_request_signal(queue)       \
    clear_consumer_signalled(queue)     \
    THREAD_MEMORY_RELEASE()             \

/**
 * Indicate to producer of the queue that consumer has been signalled.
 *
 * @param queue queue that has been signalled.
 */
#define net_cancel_signal(queue)        \
    set_consumer_signalled(queue)       \
    THREAD_MEMORY_RELEASE()             \

/**
 * Consumer of the queue requires signalling.
 *
 * @param queue queue to check.
 */
#define net_require_signal(signal, queue)       \
    get_consumer_signalled(signalled, queue)    \
    var signal = (!signalled);

