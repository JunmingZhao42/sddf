/**
 * Check if the network queue queue is empty.
 *
 * @param queue queue to check.
 *
 * @return true indicates the queue is empty, false otherwise.
 */
fun net_queue_empty(1 queue_ptr) {
    /*@ ensures (retval == 1) || (retval == 0) @*/
    get_tail(tail, queue_ptr)
    get_head(head, queue_ptr)
    var empty = (tail - head) == 0;
    return empty;
}

/**
 * Check if the network queue is full.
 *
 * @param queue queue to check.
 *
 * @return true indicates the queue is full, false otherwise.
 */
fun net_queue_full(1 queue, 1 length) {
    /*@ ensures length == old(length) @*/
    /*@ ensures (retval == 1) || (retval == 0) @*/
    get_tail(tail, queue)
    get_head(head, queue)
    var full = (tail - head) == length;
    return full;
}

/**
 * Enqueue an element into a queue.
 *
 * @param queue queue to enqueue into.
 * @param capacity capacity of the queue.
 * @param buffer buffer descriptor for buffer to be enqueued.
 *
 * @return -1 when queue is full, 0 on success.
 */
fun net_enqueue(1 queue, 1 capacity, 1 buffer_addr) {
    /*@ requires capacity > 0 @*/
    /*@ requires buffer_addr % @biw == 0 @*/
    /*@ requires buffer_addr >= @base @*/
    /*@ requires (buffer_addr/@biw + 2) <= alen(heap) @*/
    /*@ requires acc(heap[buffer_addr/@biw]) @*/
    /*@ requires acc(heap[(buffer_addr/@biw) + 1]) @*/
    /*@ ensures acc(heap[buffer_addr/@biw]) @*/
    /*@ ensures acc(heap[(buffer_addr/@biw) + 1]) @*/
    var 1 full = net_queue_full(queue, capacity);
    if (full) {
        return -1;
    }

    get_tail(tail, queue)
    var 1 idx = pnk_modulo(tail, capacity);
    var buff = buffer_addr_idx(idx, queue);

    var buffer = lds {1,1} buffer_addr;
    !stw buff, (buffer.0);
    !stw buff + @biw, (buffer.1);

    tail = tail + 1;
    set_tail(tail, queue)
    return 0;
}

/**
 * Dequeue an element from the network queue.
 *
 * @param queue queue handle to dequeue from.
 * @param capacity capacity of the queue.
 * @param buffer pointer to buffer descriptor for buffer to be dequeued.
 *
 * @return -1 when queue is empty, 0 on success.
 */
fun net_dequeue(1 queue, 1 capacity, 1 temp_addr) {
    /*@ requires capacity > 0 @*/
    /*@ requires temp_addr % @biw == 0 @*/
    /*@ requires temp_addr >= @base @*/
    /*@ requires (temp_addr/@biw + 2) <= alen(heap) @*/
    /*@ requires acc(heap[temp_addr/@biw]) @*/
    /*@ requires acc(heap[(temp_addr/@biw) + 1]) @*/
    /* @ ensures acc(heap[temp_addr/@biw]) @*/
    /* @ ensures acc(heap[(temp_addr/@biw) + 1]) @*/
    var 1 empty = net_queue_empty(queue);
    if (empty) {
        return -1;
    }

    get_head(head, queue)
    var 1 idx = pnk_modulo(head, capacity);
    var buff = buffer_addr_idx(idx, queue);

    var io_or_offset = 0;
    !ldw io_or_offset, buff;
    st temp_addr, io_or_offset;
    var len = 0;
    !ldw len, buff + @biw;
    st temp_addr + @biw, len;

    head = head + 1;
    set_head(head, queue)
    return 0;
}

/**
 * Indicate to producer of the queue that consumer requires signalling.
 *
 * @param queue queue that requires signalling upon enqueuing.
 */
fun net_request_signal(1 queue_ptr)
{
    var signal = 0;
    !st8 queue_ptr + 2 * @biw, signal;
    return 0;
}

/**
 * Indicate to producer of the queue that consumer has been signalled.
 *
 * @param queue queue that has been signalled.
 */
fun net_cancel_signal(1 queue_ptr)
{
    var signal = 1;
    !st8 queue_ptr + 2 * @biw, signal;
    return 0;
}

/**
 * Consumer of the queue requires signalling.
 *
 * @param queue queue to check.
 */

fun net_require_signal(1 queue_ptr)
{
    /*@ ensures (retval == 1) || (retval == 0) @*/
    var signalled = 0;
    !ld8 signalled, queue_ptr + 2 * @biw;
    return !signalled;
}