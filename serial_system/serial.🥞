fun main() {
	// memset @base[7] to @base[64] to 0 for global variables
	var start = @base + 8*7;
	var end = @base + 512;
	while (start < end) {
		stw start, 0;
		start = start + 8;
	}

	// TODO: not sure why value under @base is touched
	reset_uart_base();

	// init the shared ring buffers
	var rx_ring = 0;
	var tx_ring = 0;
	rx_ring = get_rx_ring();
	tx_ring = get_tx_ring();

	var rx_avail = 0;
	var tx_avail = 0;
	rx_avail = get_rx_avail();
	tx_avail = get_tx_avail();

	var rx_used = 0;
	var tx_used = 0;
	rx_used = get_rx_used();
	tx_used = get_tx_used();

	ring_init(rx_ring, rx_avail, rx_used);
	ring_init(tx_ring, tx_avail, tx_used);
	return 0;
}

export fun handle_tx() {
	var local_buff = @base + 544;
	var ret = 0;
	// 1: dequeue_used tx
	ret = serial_driver_dequeue_used(1, local_buff);
	if (ret == 0) {
		return -1;
	}

	var temp = 1;
	while (temp > 0) {
		// break when the content is 0
		temp = ld8 local_buff;
		if (temp < 1) {
			break;
		}

		while (true) {
			var tx_fifo_ret = 0;
			tx_fifo_ret = internal_is_tx_fifo_busy();
			if (tx_fifo_ret == 1) {
				continue;
			} else {
				if (temp == 10) {
					// 13: '\n'
					putchar_regs(13);
				}
				while (true) {
					tx_fifo_ret = internal_is_tx_fifo_busy();
					if (tx_fifo_ret != 1) {
						putchar_regs(temp);
						break;
					}
				}
				break;
			}
		}
		local_buff = local_buff + 1;
	}

	// 1: enqueue_avail tx
	ret = serial_enqueue_avail(1);
	return ret;
}

export fun handle_rx() {
	increment_num_chars();
  	return 0;
}

export fun handle_irq() {
	var got_char = 0;
	got_char = getchar();

	if (got_char == -1) {
		return -1;
	} else {
		while true {
			var buffer_addr = @base + 544;
			var dequeue_ret = 0;
			// 0: dequeue_avail rx
			dequeue_ret = serial_dequeue_avail(0, buffer_addr);
			if (dequeue_ret != 0) {
				// dequeue_avail ring is empty
				return -1;
			}
			var enqueue_ret = 0;
			// 0: enqueue_used rx
			enqueue_ret = serial_enqueue_used(0, got_char, buffer_addr);
			if (enqueue_ret != 0) {
				return -1;
			}
		}
	}
}
