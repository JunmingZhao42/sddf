fun ring_init(1 ring_addr, 1 avail, 1 used) {
    stw ring_addr, used;
    stw ring_addr + 8, avail;
    stw ring_addr + 16, 0;
    // TODO: init avail and used to be empty?
	return 0;
}

// #define SIZE 512

/*
fun ring_write_idx(1 ring_addr) {
    var write_idx_addr = @base;
    @ld_hw(ring_addr, 1, write_idx_addr, 1);
    var write_idx = 0;
    write_idx = lds {1} write_idx_addr;
    return write_idx;
}

fun ring_read_idx(1 ring_addr) {
    var read_idx_addr = @base;
    @ld_hw(ring_addr + 4, 1, read_idx_addr, 1);
    var read_idx = 0;
    read_idx = lds {1} read_idx_addr;
    return read_idx;
}

fun incr_ring_write_idx(1 ring_addr) {
    var write_idx_addr = @base;
    @ld_hw(ring_addr, 1, write_idx_addr, 1);
    var write_idx = 0;
    write_idx = lds {1} write_idx_addr;
    var write_idx_addr2 = @base + 4;
    stw write_idx + 1, write_idx_addr2;
    @ld_hw(write_idx_addr2, 1, ring_addr, 1);
    return 0;
}

// Returns `&ring->buffers[idx % SIZE]`, assuming SIZE=512
fun ring_buffer_get(1 ring_addr, 1 idx) {
    var idx = 0;
    idx = pnk_modulo512(write_idx);

    // TODO: hardcode assumpution about `struct ring_buffer`
    var buffer = 0;
    !ldw buffer, ring_addr + 8;
    // 24 is sizeof(buff_desc_t) which is element of `buffers` array
    var offset = 8 + 24 * idx;
    buffer = buffer + offset;
    return buffer;
}

fun ring_empty(1 ring_addr) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_write_idx(ring_addr);
    read_idx = ring_read_idx(ring_addr);
    var ret = 0;
    ret = (pnk_modulo512(write_idx - read_idx) != 0);
    return ret;
}

fun ring_full(1 ring_addr) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_write_idx(ring_addr);
    read_idx = ring_read_idx(ring_addr);
    var ret = 0;
    ret = (pnk_modulo512(write_idx - read_idx + 1) == 0);
    return ret;
}

fun ring_size(1 ring_addr) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_write_idx(ring_addr);
    read_idx = ring_read_idx(ring_addr);
    return write_idx - read_idx;
}

fun notify(1 ring_handle_addr) {
    var notify = 0;
    // TODO: hardcode assumption about `struct ring_handle`
    notify = lds {1} ring_handle_addr + 3;
    @funcall(notify, 1, 0, 0);
    return 0;
}

// TODO: do we still need cookie?
fun enqueue(1 ring_addr, 1 buffer, 1 len, 1 cookie) {
    if (ring_full(ring_addr)) {
        return -1;
    }
    var write_idx = 0;
    write_idx = ring_write_idx(ring_addr);
    var buffer_ptr = 0;
    buffer_ptr = ring_buffer_get(ring_addr, write_idx);

    // assign buff_desc->encoded_addr
    !stw buffer, buffer_ptr;
    // assign buff_desc->len
    !st8 len, buffer_ptr + 4;
    // assign buff_desc->cookie
    !stw cookie, buffer_ptr + 6;
    // ring->write_idx ++

    @THREAD_MEMORY_RELEASE(42,0,42,0);
}

fun enqueue_used() {
    return -1;
}

fun driver_dequeue() {
    return -1;
}

fun driver_enqueue() {
    return -1;
}

fun enqueue_avail() {
    return -1;
}

*/