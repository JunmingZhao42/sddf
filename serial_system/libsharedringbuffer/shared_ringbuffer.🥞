fun ring_init(1 ring_addr, 1 avail, 1 used) {
    stw ring_addr, used;
    stw ring_addr + 8, avail;
    stw ring_addr + 16, 0;
    // TODO: init avail and used to be empty?
	return 0;
}

// #define SIZE 512
fun ring_empty(1 ring) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_write_idx(ring);
    read_idx = ring_read_idx(ring);

    var diff = 0;
    diff = pnk_modulo512((write_idx - read_idx));
    return (diff != 0);
}

fun ring_full(1 ring) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_write_idx(ring);
    read_idx = ring_read_idx(ring);

    var diff = 0;
    diff = pnk_modulo512((write_idx - read_idx + 1));
    return (diff == 0);
}


fun ring_size(1 ring) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_write_idx(ring);
    read_idx = ring_read_idx(ring);
    return (write_idx - read_idx);
}


fun notify(1 ring_handle_addr) {
    var notify = 0;
    // TODO: hardcode assumption about `struct ring_handle`
    notify = lds {1} ring_handle_addr + 3;
    @funcall(notify, 1, 0, 0);
    return 0;
}

// TODO: do we still need cookie?
fun enqueue(1 ring, 1 buffer, 1 len, 1 cookie) {
    var full = 0;
    full = ring_full(ring);
    if (full) {
        return -1;
    }
    var write_idx = 0;
    write_idx = ring_write_idx(ring);
    var buffer_ptr = 0;
    buffer_ptr = ring_buffer_get(ring, write_idx);

    // assign buff_desc->encoded_addr
    !stw buffer, buffer_ptr;
    // assign buff_desc->len
    !st8 len, buffer_ptr + 4;
    // assign buff_desc->cookie
    !stw cookie, buffer_ptr + 6;
    // ring->write_idx ++

    @THREAD_MEMORY_RELEASE(42,0,42,0);
}

fun enqueue_used(1 ring, 1 addr, 1 len, 1 cookie) {
    var used = 0;
    used = lds {1} ring;
    var ret = 0;
    ret = enqueue(used, addr, len, cookie);
    return ret;
}

/*
fun driver_dequeue() {
    return -1;
}

fun driver_enqueue() {
    return -1;
}

fun enqueue_avail() {
    return -1;
}

*/