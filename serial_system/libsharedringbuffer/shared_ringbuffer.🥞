fun ring_init(1 ring_addr, 1 avail, 1 used) {
    stw ring_addr, used;
    stw ring_addr + 8, avail;
    stw ring_addr + 16, 0;
    // TODO: init avail and used to be empty?
	return 0;
}

// #define SIZE 512
fun ring_empty(1 ring) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_buffer_write_idx(ring);
    read_idx = ring_buffer_read_idx(ring);

    var diff = 0;
    diff = pnk_modulo512((write_idx - read_idx));
    return (diff == 0);
}

fun ring_full(1 ring) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_buffer_write_idx(ring);
    read_idx = ring_buffer_read_idx(ring);

    var diff = 0;
    diff = pnk_modulo512((write_idx - read_idx + 1));
    return (diff == 0);
}


fun ring_size(1 ring) {
    var write_idx = 0;
    var read_idx = 0;
    write_idx = ring_buffer_write_idx(ring);
    read_idx = ring_buffer_read_idx(ring);
    return (write_idx - read_idx);
}


fun notify(1 ring_handle_addr) {
    var notify = (lds {1} ring_handle_addr + 16);
    @funcall(notify, 1, 0, 0);
    return 0;
}

fun enqueue(1 ring, 1 buffer, 1 len, 1 cookie) {
    var full = 0;
    full = ring_full(ring);
    if (full) {
        return -1;
    }

    var write_idx = 0;
    write_idx = ring_buffer_write_idx(ring);
    var buffer_ptr = 0;
    buffer_ptr = ring_buffer_buffers(ring, write_idx);

    !stw buffer, buffer_ptr;
    !st8 len, buffer_ptr + 8;
    !stw cookie, buffer_ptr + 16;

    ring_buffer_write_idx_set(ring, (write_idx + 1));
    @THREAD_MEMORY_RELEASE(0,42,0,42);
    return 0;
}

fun enqueue_used(1 ring, 1 addr, 1 len, 1 cookie) {
    var used_ring = (lds {1} ring);
    var ret = 0;
    ret = enqueue(used_ring, addr, len, cookie);
    return ret;
}

fun enqueue_avail(1 ring, 1 addr, 1 len, 1 cookie) {
    var avail_ring = (lds {1} ring + 8);
    var ret = 0;
    ret = enqueue(avail_ring, addr, len, cookie);
    return ret;
}

/*
fun driver_dequeue() {
    return -1;
}

fun driver_enqueue() {
    return -1;
}
*/