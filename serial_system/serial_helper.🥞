/* Store uart_base address value in @base */
fun reset_uart_base() {
	var uart_base = @base;
    @get_shared_mem_addr(0, 6, uart_base, 1);
	return 0;
}

/* Return the address of the UART registers */
fun get_uart_base() {
	var regs = 0;
	regs = lds {1} @base;
	return regs;
}

fun get_rx_avail() {
	var rx_avail_addr = @base + 8;
	return (lds {1} rx_avail_addr);
}

fun get_rx_used() {
	var rx_used_addr = @base + 8*2;
	return (lds {1} rx_used_addr);
}

fun get_tx_avail() {
	var tx_avail_addr = @base + 8*3;
	return (lds {1} tx_avail_addr);
}

fun get_tx_used() {
	var tx_used_addr = @base + 8*4;
	return (lds {1} tx_used_addr);
}

fun get_shared_dma_vaddr() {
	var vaddr_addr = @base + 8*5;
	return (lds {1} vaddr_addr);
}

fun reset_num_chars() {
	var num_addr = @base + 8*6;
	var num = 0;
	stw num_addr, num;
	return 0;
}

fun get_num_chars() {
	var num_addr = @base + 8*6;
	return (lds {1} num_addr);
}

fun increment_num_chars() {
	var num_addr = @base + 8*6;
	var num = (lds {1} num_addr);
	stw num_addr, num + 1;
	return 0;
}

fun decrement_num_chars() {
	var num_addr = @base + 8*6;
	var num = (lds {1} num_addr);
	stw num_addr, num - 1;
	return 0;
}

fun get_rx_ring() {
	var ring_base = @base + 8*7;
	return ring_base;
}

fun get_tx_ring() {
	var ring_base = @base + 8*11;
	return ring_base;
}

/* Return the character in uart_base->rxd (receiver register) */
fun getchar() {
    var regs = 0;
	regs = get_uart_base();

    var reg = 0;
    var c_reg = -1;
    // loation of SR2, TODO: don't hardcode this
    var sr2 = 0;
    !ld8 sr2, (regs + 152);

    // sr2 & UART_SR2_RXFIFO_RDR BIT(1)
    if (sr2 & 1) {
		// TODO: ldw triggers segfault here
		var reg_b = @base + 512;
		@transfer_hw(regs, 1, reg_b, 1);
		reg = lds {1} reg_b;
		// reg & UART_URXD_READY_MASK BIT(15) 0x8000
		if ((reg & 32768) != 0) {
			// UART_BYTE_MASK 0xFF
			c_reg = reg & 255;
		}
    }

    return c_reg;
}

fun internal_is_tx_fifo_busy() {
    var regs = 0;
	regs = get_uart_base();

	/* check the TXFE (transmit buffer FIFO empty) flag, which is cleared
       automatically when data is written to the TxFIFO. Even though the flag
       is set, the actual data transmission via the UART's 32 byte FIFO buffer
       might still be in progress.
    */

	// loation of SR2, todo: don't hardcode this
	var sr2 = 0;
	!ldw sr2, (regs + 152);

	if ((sr2 & 16384) == 0) {
		return 1;
	} else {
		return 0;
	}
}

// Putchar that is using the hardware FIFO buffers --> Switch to DMA later
fun putchar_regs(1 c) {
    var regs = 0;
	regs = get_uart_base();

    !st8 c, regs + 64; // regs->txd
    return 0;
}

fun serial_dequeue_avail(1 rx_tx, 1 buffer_addr) {
	/* From our serial driver, this function is only ever called in the handle irq function
       to attempt to service all get char requests. Check here how many get char requests we
       have that are outstanding. If none are outstanding then return -1 in a array,
       otherwise continue with the dequeue.
	*/
	var num_chars = 0;
	num_chars = get_num_chars();
	if (num_chars <= 0) {
		return 1;
	}

	// got some chars to get
	var ring = 0;
	if (rx_tx == 0) {
		ring = get_rx_ring();
	} else {
		ring = get_tx_ring();
	}

	// here we discarded the returned len and cookie
	var len_ptr = @base + 512;
	var cookie_ptr = @base + 520;
	var ret = 0;
	ret = dequeue_avail(ring, buffer_addr, len_ptr, cookie_ptr);
	if (ret == 0) {
		decrement_num_chars();
	}
	// ret != 0 means the buffer was empty
	return ret;
}

fun serial_enqueue_used(1 rx_tx, 1 input, 1 buffer_addr) {
	var buffer = (lds {1} buffer_addr);
	!st8 input, buffer;

	var ring = 0;
	if (rx_tx == 0) {
		ring = get_rx_ring();
	} else {
		ring = get_tx_ring();
	}

	// TODO: here cookie = 0
	var ret = 0;
	ret = enqueue_used(ring, buffer, 1, 0);
	return ret;
}

fun serial_driver_dequeue_used(1 rx_tx, 1 copy_dst) {
	var ring = 0;
	if (rx_tx == 0) {
		ring = get_rx_ring();
	} else {
		ring = get_tx_ring();
	}

	var buffer_ptr = @base + 512;
	var len_ptr = @base + 520;
	var cookie_ptr = @base + 528;
	var ret = 0;
	ret = dequeue_used(ring, buffer_ptr, len_ptr, cookie_ptr);

	if (ret != 0) {
		return 0;
	} else {
		var buffer_len = (lds {1} len_ptr);
		if (buffer_len > 1024) {
			return -1;
		}
		if (buffer_len > 0) {
			var buffer = (lds {1} buffer_ptr);
			pnk_memcpy(copy_dst, buffer, buffer_len);
		}
		return buffer_len;
	}
}

fun serial_enqueue_avail(1 rx_tx) {
	var ring = 0;
	if (rx_tx == 0) {
		ring = get_rx_ring();
	} else {
		ring = get_tx_ring();
	}

	// TODO: not sure why here we don't need buffer, len, cookie
	var ret = 0;
	ret = enqueue_avail(ring, 0, 0, 0);
	return ret;
}
