fun getchar() {
    var uart_base = @base;
    @get_uart_base(uart_base,1,0,0);
    var regs = 0;
    regs = lds {1} uart_base;

    var reg = 0;
    var c_reg = -1;

    // loation of SR2, TODO: don't hardcode this
    var sr2 = 0;
    !ld8 sr2, (regs + 152);

    // sr2 & UART_SR2_RXFIFO_RDR BIT(1)
    if (sr2 & 1) {
      // TODO: ldw triggers segfault here
      var reg_b = @base;
      @ld_hw(reg_b, 1, regs, 1);
      reg = lds {1} reg_b;
      // reg & UART_URXD_READY_MASK BIT(15) 0x8000
      if ((reg & 32768) != 0) {
        // UART_BYTE_MASK 0xFF
        c_reg = reg & 255;
      }
    }

    return c_reg;
}


fun internal_is_tx_fifo_busy() {
	var uart_base = @base;
	@get_uart_base(uart_base,1,0,0);
	var regs = 0;
	regs = lds {1} uart_base;

	/* check the TXFE (transmit buffer FIFO empty) flag, which is cleared
       automatically when data is written to the TxFIFO. Even though the flag
       is set, the actual data transmission via the UART's 32 byte FIFO buffer
       might still be in progress.
    */

	// loation of SR2, todo: don't hardcode this
	var sr2 = 0;
	!ldw sr2, (regs + 152);

	if ((sr2 & 16384) == 0) {
		return 1;
	} else {
		return 0;
	}
}

fun ffiputchar_regs(1 c) {
    /*
    var uart_base = @base;
    @get_uart_base(uart_base, 1, 0, 0);
    var regs = 0;
    regs = lds {1} uart_base;
    !st8 c, regs + 64; // regs->txd
    */
    @putchar_regs(c, 0, 0, 0);
    return 0;
}

fun increment_num_chars() {
	var num_c = @base;
	@num_to_get_chars_addr(num_c,1,0,0);
	var num_addr = 0;
	num_addr = lds {1} num_c;

	var num_to_get_chars = 0;
	!ldw num_to_get_chars, num_addr;

	num_to_get_chars = num_to_get_chars + 1;
	!stw num_to_get_chars, num_addr;
	return 0;
}

fun ffiserial_dequeue_avail(1 rx_tx) {
	var num_c = @base;
	@num_to_get_chars_addr(num_c,1,0,0);
	var num_addr = 0;
	num_addr = lds {1} num_c;

	var num_to_get_chars = 0;
	!ldw num_to_get_chars, num_addr;
	if (num_to_get_chars <= 0) {
		return 1;
	}

	var ring_c = @base + 4;
	if (rx_tx == 0) {
		@get_rx_ring(ring_c,1,0,0);
	} else {
		@get_tx_ring(ring_c,1,0,0);
	}

	var ring_addr = 0;
	ring_addr = lds {1} ring_c;
	var ret_addr = @base + 8;
	@dequeue_avail(ring_addr, 0, ret_addr, 0);
	var success = 0;
	success = lds {1} ret_addr;

	if (success != 0) {
		// -1, means that the ring buffer is empty
		return success;
	} else {
		// global_serial_driver_data.num_to_get_chars--;
		num_to_get_chars = num_to_get_chars - 1;
		!stw num_to_get_chars, num_addr;
	}
	return success;
}
