fun getchar() {
    var uart_base = @base;
    @get_uart_base(uart_base,1,0,0);
    var regs = 0;
    regs = lds {1} uart_base;

    var reg = 0;
    var c_reg = -1;

    // loation of SR2, TODO: don't hardcode this
    var sr2 = 0;
    !ld8 sr2, (regs + 152);

    // sr2 & UART_SR2_RXFIFO_RDR BIT(1)
    if (sr2 & 1) {
      // TODO: ldw triggers segfault here
      var reg_b = @base;
      @ld_hw(reg_b, 1, regs, 1);
      reg = lds {1} reg_b;
      // reg & UART_URXD_READY_MASK BIT(15) 0x8000
      if ((reg & 32768) != 0) {
        // UART_BYTE_MASK 0xFF
        c_reg = reg & 255;
      }
    }

    return c_reg;
}


fun ffiinternal_is_tx_fifo_busy() {
    var uart_base = @base;
    @get_uart_base(uart_base, 1, uart_base, 1);

    var sr2 = 0;
    // loation of SR2, todo: don't hardcode this
    !ldw sr2, (uart_base + 152);

    if ((sr2 & 16384) == 0) {
      return 1;
    } else {
      return 0;
    }
}

fun ffiputchar_regs(1 c) {
    /*
    var uart_base = @base;
    @get_uart_base(uart_base, 1, 0, 0);
    var regs = 0;
    regs = lds {1} uart_base;
    !st8 c, regs + 64; // regs->txd
    */
    @putchar_regs(c, 0, 0, 0);
    return 0;
}

fun num_to_get_chars() {
    var num_chars = @base;
    @num_to_get_chars(num_chars, 1, num_chars, 1);
    var num_chars_ret = ld8 num_chars;
    return num_chars_ret;
}
